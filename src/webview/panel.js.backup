// GitStorm Panel Controller
class PanelController {
    constructor() {
        this.vscode = window.acquireVsCodeApi();
        this.currentBranch = null;
        this.selectedCommits = new Set();
        this.commits = [];
        this.branches = [];
        this.searchTerm = '';
        this.commitsSearchTerm = '';
        this.selectedUser = 'all';
        this.panelSizes = { branches: 280, commits: 400 };
        this.searchTimeout = null;
        this.commitsSearchTimeout = null;
        this.compareAgainst = localStorage.getItem('gitstorm-compare-against') || 'previous'; // 'previous', 'branch', 'working'
        this.selectedCompareBranch = localStorage.getItem('gitstorm-compare-branch') || null;
        this.fileCompareData = {}; // Store compare data for file items
        this.selectedFileId = null; // Track currently selected file
        this.commitsCompareAgainst = localStorage.getItem('gitstorm-commits-compare-against') || 'none'; // 'none' or branch name
        this.initialize();
    }

    initialize() {
        console.log('GitStorm WebView loaded!');
        this.setupEventListeners();
        this.setupResizeHandlers();
        this.setupMutationObserver();
        this.setupContextMenu();
        
        // Send a test message to the extension
        this.vscode.postMessage({ command: 'test', data: 'WebView is ready' });
    }

    setupEventListeners() {
        // Message listener for content updates
        window.addEventListener('message', (event) => {
            const message = event.data;
            console.log('WebView received message:', message);
            console.log('Message command:', message.command);
            switch (message.command) {
                case 'updateContent':
                    console.log('Processing updateContent:', { branches: message.branches?.length, commits: message.commits?.length, error: message.error, hasUncommittedChanges: message.hasUncommittedChanges });
                    this.updateContent(message.branches, message.commits, message.error, message.hasUncommittedChanges);
                    break;
                case 'updatePanelSizes':
                    this.panelSizes = message.sizes;
                    this.restorePanelSizes();
                    break;
                case 'commitDetails':
                    console.log('Frontend: Received commitDetails message');
                    console.log('Frontend: Commit:', message.commit);
                    console.log('Frontend: Files:', message.files);
                    console.log('Frontend: Files length:', message.files ? message.files.length : 'undefined');
                    this.updateFileChangesPanel(message.commit, message.files);
                    break;
                case 'multiCommitFiles':
                    console.log('Received multi-commit files:', message.files);
                    this.updateFileChangesPanel(null, message.files);
                    break;
                case 'updateCommitsWithCompare':
                    console.log('Received commits with compare:', message.commits?.length, 'for branch:', message.branch, 'excluding:', message.compareBranch);
                    this.updateCommitsWithCompare(message.commits, message.branch, message.compareBranch, message.error);
                    break;
                default:
                    console.log('WebView received unknown message command:', message.command);
                    break;
            }
        });

        // DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('DOM Content Loaded!');
                this.restorePanelSizes();
                this.setupSearchHandlers();
            });
        } else {
            console.log('DOM already loaded!');
            this.restorePanelSizes();
            this.setupSearchHandlers();
            this.setupCommitsSearchHandlers();
        }
    }

    setupResizeHandlers() {
        const resizeHandles = document.querySelectorAll('.resize-handle');
        
        resizeHandles.forEach(handle => {
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                
                const panel = handle.closest('.panel');
                startWidth = panel.offsetWidth;
                
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaX = e.clientX - startX;
                const newWidth = Math.max(150, Math.min(600, startWidth + deltaX));
                
                const panel = handle.closest('.panel');
                const panelType = handle.getAttribute('data-panel');
                
                if (panelType === 'branches') {
                    panel.style.width = newWidth + 'px';
                    this.panelSizes.branches = newWidth;
                } else if (panelType === 'commits') {
                    panel.style.width = newWidth + 'px';
                    this.panelSizes.commits = newWidth;
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    this.savePanelSizes();
                }
            });
        });
    }

    setupMutationObserver() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList' || mutation.type === 'subtree') {
                    const branchesContent = document.getElementById('branchesContent');
                    const commitsContent = document.getElementById('commitsContent');
                    
                    if (branchesContent || commitsContent) {
                        console.log('Content changed, restoring panel sizes...');
                        setTimeout(() => {
                            this.restorePanelSizes();
                        }, 50);
                    }
                }
            });
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: false
        });
    }

    setupContextMenu() {
        this.contextMenu = document.getElementById('contextMenu');
        this.contextMenuData = null;
        
        // Hide context menu when clicking elsewhere
        document.addEventListener('click', () => {
            this.hideContextMenu();
        });
        
        // Hide context menu on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideContextMenu();
            }
        });
        
        // Handle context menu item clicks
        this.contextMenu.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = e.target.closest('.context-menu-item')?.dataset.action;
            if (action) {
                this.handleContextMenuAction(action);
            }
        });

        // Handle text selection context menu
        document.addEventListener('mouseup', (e) => {
            const selection = window.getSelection();
            if (selection && selection.toString().trim().length > 0) {
                // Show context menu for text selection
                setTimeout(() => {
                    this.showContextMenu(e.clientX, e.clientY, 'text', { text: selection.toString() });
                }, 100);
            }
        });

        // Handle right-click on general areas
        document.addEventListener('contextmenu', (e) => {
            // Only show default context menu if no specific element handled it
            if (!e.target.closest('[oncontextmenu]')) {
                e.preventDefault();
                this.showContextMenu(e.clientX, e.clientY, 'default', {});
            }
        });
    }

    showContextMenu(x, y, type, data) {
        this.contextMenuData = { type, data };
        
        // Reset all menu items visibility
        const items = this.contextMenu.querySelectorAll('.context-menu-item');
        items.forEach(item => {
            item.style.display = 'none';
        });
        
        // Show relevant items based on type
        switch (type) {
            case 'branch':
                this.showBranchContextMenu();
                break;
            case 'commit':
                this.showCommitContextMenu();
                break;
            case 'file':
                this.showFileContextMenu();
                break;
            case 'directory':
                this.showDirectoryContextMenu();
                break;
            case 'panel':
                this.showPanelContextMenu();
                break;
            case 'uncommitted':
                this.showUncommittedChangesContextMenu();
                break;
            case 'text':
                this.showTextContextMenu();
                break;
            default:
                this.showDefaultContextMenu();
        }
        
        // Position the context menu
        this.contextMenu.style.left = x + 'px';
        this.contextMenu.style.top = y + 'px';
        this.contextMenu.style.display = 'block';
        
        // Adjust position if menu goes off screen
        const rect = this.contextMenu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            this.contextMenu.style.left = (x - rect.width) + 'px';
        }
        if (rect.bottom > window.innerHeight) {
            this.contextMenu.style.top = (y - rect.height) + 'px';
        }
    }

    hideContextMenu() {
        this.contextMenu.style.display = 'none';
        this.contextMenuData = null;
    }

    showBranchContextMenu() {
        // Show branch-specific actions
        this.contextMenu.querySelector('[data-action="checkout"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="merge"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="delete-branch"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
    }

    showCommitContextMenu() {
        // Show commit-specific actions
        this.contextMenu.querySelector('[data-action="create-branch"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="cherry-pick"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="revert"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="diff"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
        
        // Show squash option only if multiple commits are selected
        if (this.selectedCommits && this.selectedCommits.size > 1) {
            this.contextMenu.querySelector('[data-action="squash"]').style.display = 'flex';
        }
    }

    showFileContextMenu() {
        // Show file-specific actions
        this.contextMenu.querySelector('[data-action="open"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="diff"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="copy-path"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="reveal"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
    }

    showDirectoryContextMenu() {
        // Show directory-specific actions
        this.contextMenu.querySelector('[data-action="copy-path"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="reveal"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
    }

    showPanelContextMenu() {
        // Show panel-specific actions
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
    }

    showUncommittedChangesContextMenu() {
        // Show uncommitted changes-specific actions
        this.contextMenu.querySelector('[data-action="commit"]').style.display = 'flex';
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
    }

    showTextContextMenu() {
        // Show text-specific actions
        this.contextMenu.querySelector('[data-action="copy"]').style.display = 'flex';
    }

    showDefaultContextMenu() {
        // Show default actions
        this.contextMenu.querySelector('[data-action="refresh"]').style.display = 'flex';
    }

    handleContextMenuAction(action) {
        if (!this.contextMenuData) return;
        
        const { type, data } = this.contextMenuData;
        
        switch (action) {
            case 'copy':
                this.copyToClipboard(data.text || data.branchName || data.commitHash || data.filePath || '');
                break;
            case 'open':
                if (type === 'file') {
                    this.openFile(data.filePath);
                }
                break;
            case 'diff':
                if (type === 'file') {
                    this.showFileDiff(data.filePath, data.fileId);
                } else if (type === 'commit') {
                    this.showCommitDiff(data.commitHash);
                }
                break;
            case 'copy-path':
                if (type === 'file') {
                    this.copyToClipboard(data.filePath);
                } else if (type === 'directory') {
                    this.copyToClipboard(data.directoryName);
                }
                break;
            case 'reveal':
                if (type === 'file') {
                    this.revealFileInExplorer(data.filePath);
                } else if (type === 'directory') {
                    this.revealDirectoryInExplorer(data.directoryName);
                }
                break;
            case 'checkout':
                if (type === 'branch') {
                    this.checkoutBranch(data.branchName);
                }
                break;
            case 'merge':
                if (type === 'branch') {
                    this.mergeBranch(data.branchName);
                }
                break;
            case 'delete-branch':
                if (type === 'branch') {
                    this.deleteBranch(data.branchName);
                }
                break;
            case 'create-branch':
                if (type === 'commit') {
                    this.createBranchFromCommit(data.commitHash);
                }
                break;
            case 'cherry-pick':
                if (type === 'commit') {
                    this.cherryPickCommit(data.commitHash);
                }
                break;
            case 'revert':
                if (type === 'commit') {
                    this.revertCommit(data.commitHash);
                }
                break;
            case 'squash':
                if (type === 'commit') {
                    this.squashCommits();
                }
                break;
            case 'commit':
                if (type === 'uncommitted') {
                    this.commitChanges();
                }
                break;
            case 'refresh':
                this.refreshData();
                break;
        }
        
        this.hideContextMenu();
    }

    copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Copied to clipboard:', text);
        }).catch(err => {
            console.error('Failed to copy to clipboard:', err);
        });
    }

    openFile(filePath) {
        this.vscode.postMessage({
            command: 'openWorkingFile',
            filePath: filePath
        });
    }

    showFileDiff(filePath, fileId) {
        if (fileId) {
            showFileDiffWithCompare(filePath, fileId);
        } else {
            showFileDiff(filePath, this.getCurrentCommitHash());
        }
    }

    showCommitDiff(commitHash) {
        this.vscode.postMessage({
            command: 'showCommitDiff',
            commitHash: commitHash
        });
    }

    revealFileInExplorer(filePath) {
        this.vscode.postMessage({
            command: 'revealFileInExplorer',
            filePath: filePath
        });
    }

    revealDirectoryInExplorer(directoryName) {
        this.vscode.postMessage({
            command: 'revealDirectoryInExplorer',
            directoryName: directoryName
        });
    }

    checkoutBranch(branchName) {
        this.vscode.postMessage({
            command: 'checkoutBranch',
            branchName: branchName
        });
        // Refresh the data after checkout and select the newly checked out branch
        setTimeout(() => {
            this.refreshData();
            // Select the newly checked out branch after refresh
            setTimeout(() => {
                this.selectBranch(branchName);
            }, 500);
        }, 1000);
    }

    mergeBranch(branchName) {
        this.vscode.postMessage({
            command: 'mergeBranch',
            branchName: branchName
        });
    }

    deleteBranch(branchName) {
        this.vscode.postMessage({
            command: 'deleteBranch',
            branchName: branchName
        });
    }

    createBranchFromCommit(commitHash) {
        this.vscode.postMessage({
            command: 'createBranchFromCommit',
            commitHash: commitHash
        });
    }

    cherryPickCommit(commitHash) {
        this.vscode.postMessage({
            command: 'cherryPickCommit',
            commitHash: commitHash
        });
    }

    revertCommit(commitHash) {
        this.vscode.postMessage({
            command: 'revertCommit',
            commitHash: commitHash
        });
    }

    squashCommits() {
        this.showSquashDialog();
    }

    isCurrentBranch() {
        if (!this.branches || this.branches.length === 0) return false;
        
        // Find the current branch (the one with isCurrent: true)
        const currentBranch = this.branches.find(branch => branch.isCurrent);
        if (!currentBranch) return false;
        
        // Check if the selected branch is the current branch
        return this.currentBranch === currentBranch.name;
    }

    selectUncommittedChanges() {
        console.log('Selecting uncommitted changes');
        this.selectedCommits.clear();
        this.selectedCommits.add('uncommitted');
        this.updateCommitSelection();
        
        // Show uncommitted changes in file panel
        this.vscode.postMessage({
            command: 'getUncommittedChanges'
        });
    }

    commitChanges() {
        const message = prompt('Enter commit message:');
        if (message && message.trim()) {
            this.vscode.postMessage({
                command: 'commitChanges',
                message: message.trim()
            });
        }
    }

    updateContent(branches, commits, error, hasUncommittedChanges = false) {
        console.log('Updating content:', { 
            branches: branches?.length, 
            commits: commits?.length, 
            error, 
            hasUncommittedChanges,
            currentBranch: this.currentBranch
        });
        
        // Store branches for search filtering
        if (branches && branches.length > 0) {
            this.branches = branches;
            // Find and log the current branch
            const currentBranch = branches.find(b => b.isCurrent);
            console.log('Current branch found:', currentBranch);
        }

        // Store uncommitted changes state
        this.hasUncommittedChanges = hasUncommittedChanges;
        
        // Update branches content
        const branchesContent = document.getElementById('branchesContent');
        if (branchesContent) {
            if (error) {
                branchesContent.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${error}</p></div>`;
            } else if (branches && branches.length > 0) {
                branchesContent.innerHTML = this.generateBranchesHtml(branches, this.currentBranch, this.searchTerm);
            } else {
                branchesContent.innerHTML = '<div class="loading">Loading branches...</div>';
            }
        }
        
        // Update commits content
        const commitsContent = document.getElementById('commitsContent');
        if (commitsContent) {
            if (error) {
                commitsContent.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${error}</p></div>`;
            } else if (commits && commits.length > 0) {
                this.commits = commits;
                this.populateUserFilter(commits);
                this.populateCommitsCompareFilter();
                commitsContent.innerHTML = this.generateCommitsHtml(commits, this.commitsSearchTerm, this.selectedUser);
                // Restore commit selection after content update
                setTimeout(() => this.updateCommitSelection(), 10);
            } else {
                commitsContent.innerHTML = '<div class="loading">Loading commits...</div>';
            }
        }
    }

    generateBranchesHtml(branches, selectedBranch, searchTerm = '') {
        if (!branches || branches.length === 0) {
            return '<div class="empty-state"><h3>No branches found</h3></div>';
        }

        // Filter branches based on search term
        const filteredBranches = branches.filter(branch => {
            const searchLower = searchTerm.toLowerCase();
            const branchNameLower = branch.name.toLowerCase();
            
            // For remote branches, also search the branch name without origin prefix
            if (branch.isRemote) {
                const branchNameOnly = branch.name.split('/').slice(1).join('/').toLowerCase();
                return branchNameLower.includes(searchLower) || branchNameOnly.includes(searchLower);
            }
            
            return branchNameLower.includes(searchLower);
        });

        // If no branches match the search, show message
        if (filteredBranches.length === 0 && searchTerm.length > 0) {
            return `<div class="empty-state"><h3>No branches match "${searchTerm}"</h3></div>`;
        }

        // Separate local and remote branches
        const localBranches = filteredBranches.filter(branch => branch.isLocal && !branch.isRemote);
        const remoteBranches = filteredBranches.filter(branch => branch.isRemote);

        // Group remote branches by origin
        const remoteGroups = {};
        remoteBranches.forEach(branch => {
            const parts = branch.name.split('/');
            const origin = parts[0] || 'origin';
            if (!remoteGroups[origin]) {
                remoteGroups[origin] = [];
            }
            remoteGroups[origin].push(branch);
        });

        let html = '';

        // Local branches section
        if (localBranches.length > 0) {
            html += `
                <div class="tree-section">
                    <div class="tree-section-header" onclick="toggleSection('local')">
                        <div class="tree-toggle">▼</div>
                        <div class="tree-section-title">Local</div>
                    </div>
                    <div class="tree-section-content" id="local-content">
                        ${this.generateBranchItemsHtml(localBranches, selectedBranch)}
                    </div>
                </div>
            `;
        }

        // Remote branches sections
        Object.keys(remoteGroups).sort().forEach(origin => {
            const originBranches = remoteGroups[origin];
            html += `
                <div class="tree-section">
                    <div class="tree-section-header" onclick="toggleSection('${origin}')">
                        <div class="tree-toggle">▼</div>
                        <div class="tree-section-title">Remote</div>
                        <div class="tree-section-subtitle">${origin}</div>
                    </div>
                    <div class="tree-section-content" id="${origin}-content">
                        ${this.generateBranchItemsHtml(originBranches, selectedBranch)}
                    </div>
                </div>
            `;
        });

        // If we have a search term but no results in any section, show message
        if (searchTerm.length > 0 && localBranches.length === 0 && Object.keys(remoteGroups).length === 0) {
            html = `<div class="empty-state"><h3>No branches match "${searchTerm}"</h3></div>`;
        }

        return html;
    }

    generateBranchItemsHtml(branches, selectedBranch) {
        return branches.map(branch => {
            const isSelected = (selectedBranch && branch.name === selectedBranch);
            const isCurrent = branch.isCurrent;
            const highlightClass = isSelected ? 'selected' : '';
            const currentClass = isCurrent ? 'current' : '';
            const typeIcon = branch.isRemote ? '🌐' : '🌿';
            const refs = branch.ahead || branch.behind ? 
                `+${branch.ahead || 0} -${branch.behind || 0}` : '';

            // For remote branches, show only the branch name without origin
            const displayName = branch.isRemote ? branch.name.split('/').slice(1).join('/') : branch.name;

            return `
                <div class="branch-item ${highlightClass} ${currentClass}" 
                     onclick="selectBranch('${branch.name}')" 
                     oncontextmenu="event.preventDefault(); showBranchContextMenu(event, '${branch.name}')">
                    <div class="branch-icon">${typeIcon}</div>
                    <div class="branch-name">${displayName}</div>
                    <div class="branch-refs">${refs}</div>
                </div>
            `;
        }).join('');
    }

    generateCommitsHtml(commits, searchTerm = '', selectedUser = 'all') {
        let html = '';

        // Add uncommitted changes at the top if they exist and we're on the current branch
        // If no branch is selected, we're viewing the current branch by default
        const isOnCurrentBranch = !this.currentBranch || this.isCurrentBranch();
        console.log('Uncommitted changes check:', {
            hasUncommittedChanges: this.hasUncommittedChanges,
            currentBranch: this.currentBranch,
            isOnCurrentBranch: isOnCurrentBranch,
            branches: this.branches?.map(b => ({ name: b.name, isCurrent: b.isCurrent }))
        });
        
        if (this.hasUncommittedChanges && isOnCurrentBranch) {
            html += `
                <div class="commit-item uncommitted-changes" 
                     onclick="selectUncommittedChanges()" 
                     oncontextmenu="event.preventDefault(); showUncommittedChangesContextMenu(event)">
                    <div class="commit-graph">
                        <div class="dag-commit dag-uncommitted"></div>
                    </div>
                    <div class="commit-content">
                        <div>
                            <span class="commit-hash">📝</span>
                            <span class="commit-message">Uncommitted Changes</span>
                        </div>
                        <div class="commit-meta">
                            <span class="commit-author">Working Directory</span>
                            <span class="commit-date">Now</span>
                        </div>
                    </div>
                </div>
            `;
        }

        if (!commits || commits.length === 0) {
            if (html) {
                return html;
            }
            return '<div class="empty-state"><h3>No commits found</h3></div>';
        }

        // Filter commits based on search term and user
        let filteredCommits = commits;
        
        if (searchTerm.length > 0) {
            filteredCommits = filteredCommits.filter(commit => 
                commit.message.toLowerCase().includes(searchTerm.toLowerCase())
            );
        }
        
        if (selectedUser !== 'all') {
            filteredCommits = filteredCommits.filter(commit => 
                commit.author.toLowerCase().includes(selectedUser.toLowerCase())
            );
        }

        // If no commits match the filters, show message
        if (filteredCommits.length === 0) {
            let message = 'No commits found';
            if (searchTerm.length > 0 || selectedUser !== 'all') {
                message = 'No commits match the current filters';
            }
            return `<div class="empty-state"><h3>${message}</h3></div>`;
        }

        // Generate commits with proper DAG graph
        const commitsHtml = filteredCommits.map((commit, index) => {
            console.log('Processing commit for display:', { hash: commit.hash, shortHash: commit.shortHash, message: commit.message });
            
            let date = 'Invalid Date';
            let time = '';
            try {
                if (commit.date) {
                    const dateObj = new Date(commit.date);
                    if (!isNaN(dateObj.getTime())) {
                        date = dateObj.toLocaleDateString();
                        time = dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                }
            } catch (e) {
                console.error('Date parsing error:', e);
            }
            
            const refs = commit.refs ? commit.refs.join(', ') : '';
            
            // Determine DAG graph type
            const isMerge = (commit.parents && commit.parents.length > 1) || 
                           (commit.message && commit.message.toLowerCase().includes('merge'));
            const isFirst = index === filteredCommits.length - 1; // Last commit in list is first chronologically
            const dagClass = isMerge ? 'dag-merge' : (isFirst ? 'dag-first' : 'dag-commit');
            
            // Debug logging
            if (isMerge) {
                console.log('Merge commit detected:', commit.message, 'parents:', commit.parents);
            }
            
            return `
                <div class="commit-item" 
                     onclick="selectCommit('${commit.hash}', event)" 
                     oncontextmenu="event.preventDefault(); showCommitContextMenu(event, '${commit.hash}')"
                     data-commit-hash="${commit.hash}" 
                     data-commit-index="${index}">
                    <div class="commit-graph">
                        <div class="dag-commit ${dagClass}"></div>
                    </div>
                    <div class="commit-content">
                        <div>
                            <span class="commit-hash">${commit.shortHash}</span>
                            <span class="commit-message">${commit.message}</span>
                        </div>
                        <div class="commit-meta">
                            <span class="commit-author">${commit.author}</span>
                            <span class="commit-date">${date} ${time}</span>
                            ${refs ? `<span class="commit-refs">${refs}</span>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        // Wrap in a container with CSS-based DAG graph
        return `
            <div class="commits-container">
                ${commitsHtml}
            </div>
        `;
    }


    restorePanelSizes() {
        const branchesPanel = document.querySelector('.branches-panel');
        const commitsPanel = document.querySelector('.commits-panel');
        
        console.log('Restoring panel sizes:', this.panelSizes);
        
        if (branchesPanel) {
            branchesPanel.style.width = this.panelSizes.branches + 'px';
            console.log('Set branches panel width to:', this.panelSizes.branches + 'px');
        }
        if (commitsPanel) {
            commitsPanel.style.width = this.panelSizes.commits + 'px';
            console.log('Set commits panel width to:', this.panelSizes.commits + 'px');
        }
    }

    savePanelSizes() {
        this.vscode.postMessage({
            command: 'savePanelSizes',
            sizes: this.panelSizes
        });
    }

    setupSearchHandlers() {
        const searchInput = document.querySelector('.branches-panel input[type="text"]');
        console.log('Looking for search input:', searchInput);
        
        if (searchInput) {
            // Check if handlers are already set up
            if (this.searchHandlersSetup) {
                console.log('Search handlers already setup, skipping');
                return;
            }
            
            console.log('Search input found, setting up handler');
            
            // Add the new event listener
            this.handleSearchInput = (e) => {
                const newSearchTerm = e.target.value;
                const hadText = this.searchTerm.length > 0;
                const hasText = newSearchTerm.length > 0;
                
                // Update search term immediately for clear button visibility
                this.searchTerm = newSearchTerm;
                
                // Only update clear button visibility if it actually needs to change
                if (hadText !== hasText) {
                    const clearButton = document.querySelector('.branches-panel .clear-search');
                    if (clearButton) {
                        clearButton.style.display = hasText ? 'flex' : 'none';
                        console.log('Clear button visibility changed to:', hasText ? 'visible' : 'hidden');
                    }
                }
                
                // Debounce the actual filtering to prevent excessive updates
                if (this.searchTimeout) {
                    clearTimeout(this.searchTimeout);
                }
                
                this.searchTimeout = setTimeout(() => {
                    console.log('Search term changed to:', this.searchTerm);
                    this.filterBranches();
                }, 150); // 150ms debounce
            };
            
            searchInput.addEventListener('input', this.handleSearchInput);
            console.log('Search event listener attached');
            
            // Mark handlers as setup
            this.searchHandlersSetup = true;
            
            // Set initial clear button state based on current search term
            const clearButton = document.querySelector('.branches-panel .clear-search');
            if (clearButton) {
                clearButton.style.display = this.searchTerm.length > 0 ? 'flex' : 'none';
                console.log('Initial clear button state:', clearButton.style.display);
            }
        } else {
            console.log('Search input not found! Available inputs:', document.querySelectorAll('input'));
        }
    }

    setupCommitsSearchHandlers() {
        const commitsSearchInput = document.querySelector('.commits-panel input[type="text"]');
        console.log('Looking for commits search input:', commitsSearchInput);
        
        if (commitsSearchInput) {
            // Check if handlers are already set up
            if (this.commitsSearchHandlersSetup) {
                console.log('Commits search handlers already setup, skipping');
                return;
            }
            
            console.log('Commits search input found, setting up handler');
            
            // Add the new event listener
            this.handleCommitsSearchInput = (e) => {
                const newSearchTerm = e.target.value;
                const hadText = this.commitsSearchTerm.length > 0;
                const hasText = newSearchTerm.length > 0;
                
                // Update search term immediately for clear button visibility
                this.commitsSearchTerm = newSearchTerm;
                
                // Only update clear button visibility if it actually needs to change
                if (hadText !== hasText) {
                    const clearButton = document.querySelector('.commits-panel .clear-search');
                    if (clearButton) {
                        clearButton.style.display = hasText ? 'flex' : 'none';
                        console.log('Commits clear button visibility changed to:', hasText ? 'visible' : 'hidden');
                    }
                }
                
                // Debounce the actual filtering to prevent excessive updates
                if (this.commitsSearchTimeout) {
                    clearTimeout(this.commitsSearchTimeout);
                }
                
                this.commitsSearchTimeout = setTimeout(() => {
                    console.log('Commits search term changed to:', this.commitsSearchTerm);
                    this.filterCommits();
                }, 150); // 150ms debounce
            };
            
            commitsSearchInput.addEventListener('input', this.handleCommitsSearchInput);
            console.log('Commits search event listener attached');
            
            // Mark handlers as setup
            this.commitsSearchHandlersSetup = true;
            
            // Set initial clear button state
            const clearButton = document.querySelector('.commits-panel .clear-search');
            if (clearButton) {
                clearButton.style.display = this.commitsSearchTerm.length > 0 ? 'flex' : 'none';
                console.log('Initial commits clear button state:', clearButton.style.display);
            }
        } else {
            console.log('Commits search input not found! Available inputs:', document.querySelectorAll('input'));
        }
    }

    filterBranches() {
        if (this.branches.length === 0) {
            console.log('No branches available for filtering');
            return;
        }
        
        console.log('Filtering branches with search term:', this.searchTerm);
        const branchesContent = document.getElementById('branchesContent');
        if (branchesContent) {
            const newHtml = this.generateBranchesHtml(this.branches, this.currentBranch, this.searchTerm);
            branchesContent.innerHTML = newHtml;
            
            // If we're searching, auto-expand all sections to show results
            if (this.searchTerm.length > 0) {
                setTimeout(() => {
                    const allContentElements = document.querySelectorAll('.tree-section-content');
                    allContentElements.forEach(content => {
                        content.classList.remove('collapsed');
                        const header = content.previousElementSibling;
                        if (header) {
                            header.classList.remove('collapsed');
                        }
                    });
                }, 10);
            }
            
            console.log('Updated branches content');
        } else {
            console.log('branchesContent element not found');
        }
    }

    filterCommits() {
        if (this.commits.length === 0) {
            console.log('No commits available for filtering');
            return;
        }
        
        console.log('Filtering commits with search term:', this.commitsSearchTerm, 'and user:', this.selectedUser);
        const commitsContent = document.getElementById('commitsContent');
        if (commitsContent) {
            const newHtml = this.generateCommitsHtml(this.commits, this.commitsSearchTerm, this.selectedUser);
            commitsContent.innerHTML = newHtml;
            // Restore commit selection after content update
            setTimeout(() => this.updateCommitSelection(), 10);
            console.log('Updated commits content');
        } else {
            console.log('commitsContent element not found');
        }
    }

    populateUserFilter(commits) {
        const userFilter = document.querySelector('.user-filter');
        if (!userFilter) return;

        // Get unique authors from commits
        const authors = [...new Set(commits.map(commit => commit.author))].sort();
        
        // Clear existing options except "All"
        userFilter.innerHTML = '<option value="all">All</option>';
        
        // Add author options
        authors.forEach(author => {
            const option = document.createElement('option');
            option.value = author;
            option.textContent = author;
            userFilter.appendChild(option);
        });
        
        // Set current selection
        userFilter.value = this.selectedUser;
    }

    populateCommitsCompareFilter() {
        const compareSelect = document.querySelector('.commits-compare .compare-select');
        if (!compareSelect) return;

        // Clear existing options except "None"
        compareSelect.innerHTML = '<option value="none">None</option>';
        
        // Add branch options
        this.branches.forEach(branch => {
            const option = document.createElement('option');
            option.value = branch.name;
            const displayName = branch.isRemote ? branch.name.split('/').slice(1).join('/') : branch.name;
            option.textContent = displayName;
            compareSelect.appendChild(option);
        });
        
        // Set current selection
        compareSelect.value = this.commitsCompareAgainst;
    }

    toggleSection(sectionId) {
        const content = document.getElementById(`${sectionId}-content`);
        const header = document.querySelector(`[onclick="toggleSection('${sectionId}')"]`);
        
        if (content && header) {
            const isCollapsed = content.classList.contains('collapsed');
            
            if (isCollapsed) {
                content.classList.remove('collapsed');
                header.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                header.classList.add('collapsed');
            }
        }
    }

    clearSearch() {
        const searchInput = document.querySelector('.branches-panel input[type="text"]');
        if (searchInput) {
            // Clear any pending search timeout
            if (this.searchTimeout) {
                clearTimeout(this.searchTimeout);
                this.searchTimeout = null;
            }
            
            searchInput.value = '';
            this.searchTerm = '';
            this.filterBranches();
            searchInput.focus(); // Keep focus on the input for better UX
            
            // Hide the clear button
            const clearButton = document.querySelector('.branches-panel .clear-search');
            if (clearButton) {
                clearButton.style.display = 'none';
            }
        }
    }

    clearCommitsSearch() {
        const searchInput = document.querySelector('.commits-panel input[type="text"]');
        if (searchInput) {
            // Clear any pending search timeout
            if (this.commitsSearchTimeout) {
                clearTimeout(this.commitsSearchTimeout);
                this.commitsSearchTimeout = null;
            }
            
            searchInput.value = '';
            this.commitsSearchTerm = '';
            this.filterCommits();
            searchInput.focus(); // Keep focus on the input for better UX
            
            // Hide the clear button
            const clearButton = document.querySelector('.commits-panel .clear-search');
            if (clearButton) {
                clearButton.style.display = 'none';
            }
        }
    }

    filterByUser(user) {
        this.selectedUser = user;
        this.filterCommits();
    }

    // Public methods for global functions
    selectBranch(branchName) {
        console.log('selectBranch called with:', branchName);
        this.currentBranch = branchName;
        this.selectedCommits.clear();
        
        // Reset file changes panel when branch changes
        this.clearFileChangesPanel();
        this.selectedFileId = null;
        
        // Update branch highlighting immediately
        this.updateBranchHighlighting(branchName);
        
        // Use the remembered compare against value to get commits for the new branch
        if (this.commitsCompareAgainst && this.commitsCompareAgainst !== 'none') {
            this.vscode.postMessage({
                command: 'getCommitsWithCompare',
                branch: branchName,
                compareBranch: this.commitsCompareAgainst
            });
        } else {
            // If no compare selection, use the regular branch selection
            this.vscode.postMessage({ 
                command: 'selectBranch',
                branchName: branchName
            });
        }
    }

    selectCommit(hash, event = null) {
        console.log('=== selectCommit called with:', hash, 'event:', event, '===');
        console.log('Current selectedCommits before:', Array.from(this.selectedCommits));
        
        // Check if Ctrl/Cmd key is pressed for multi-select
        const isMultiSelect = event && (event.ctrlKey || event.metaKey);
        console.log('isMultiSelect:', isMultiSelect);
        
        if (isMultiSelect) {
            // Multi-select mode: toggle the commit
            if (this.selectedCommits.has(hash)) {
                this.selectedCommits.delete(hash);
                console.log('Removed commit from selection');
            } else {
                this.selectedCommits.add(hash);
                console.log('Added commit to selection');
            }
        } else {
            // Single select mode: clear others and select only this one
            this.selectedCommits.clear();
            this.selectedCommits.add(hash);
            console.log('Single select mode: cleared others and selected only this one');
        }
        
        console.log('Selected commits after:', Array.from(this.selectedCommits));
        
        // Update commit selection visual state
        this.updateCommitSelection();
        
        // If only one commit is selected, show its file changes
        if (this.selectedCommits.size === 1) {
            const selectedHash = Array.from(this.selectedCommits)[0];
            console.log('Single commit selected, calling showCommitFileChanges for:', selectedHash);
            this.showCommitFileChanges(selectedHash);
        } else if (this.selectedCommits.size > 1) {
            // Show combined file changes for multiple commits
            console.log('Multiple commits selected, calling showMultiCommitFileChanges for:', Array.from(this.selectedCommits));
            this.showMultiCommitFileChanges(Array.from(this.selectedCommits));
        } else {
            // Clear file changes panel
            console.log('No commits selected, clearing file changes panel');
            this.clearFileChangesPanel();
        }
        console.log('=== selectCommit completed ===');
    }

    updateCommitSelection() {
        // Update visual selection state for commit items
        const commitItems = document.querySelectorAll('.commit-item');
        console.log('Updating commit selection for', commitItems.length, 'items');
        console.log('Selected commits:', Array.from(this.selectedCommits));
        
        commitItems.forEach(item => {
            const hash = item.getAttribute('data-commit-hash');
            if (hash && this.selectedCommits.has(hash)) {
                item.classList.add('selected');
                console.log('Added selected class to commit:', hash);
            } else {
                item.classList.remove('selected');
            }
        });
    }

    updateFileSelection(fileId) {
        // Clear previous file selection
        const previousSelected = document.querySelector('.file-tree-item.file.selected');
        if (previousSelected) {
            previousSelected.classList.remove('selected');
        }
        
        // Set new file selection
        if (fileId) {
            const fileItem = document.querySelector(`[data-file-id="${fileId}"]`);
            if (fileItem) {
                fileItem.classList.add('selected');
                this.selectedFileId = fileId;
                console.log('Selected file:', fileId);
            }
        } else {
            this.selectedFileId = null;
        }
    }

    showCommitFileChanges(hash) {
        console.log('Showing file changes for commit:', hash);
        this.vscode.postMessage({
            command: 'getCommitDetails',
            hash: hash
        });
    }

    showMultiCommitFileChanges(hashes) {
        console.log('Showing file changes for multiple commits:', hashes);
        this.vscode.postMessage({
            command: 'getMultiCommitFiles',
            hashes: hashes
        });
    }

    clearFileChangesPanel() {
        const filesContent = document.getElementById('filesContent');
        if (filesContent) {
            filesContent.innerHTML = `
                <div class="empty-state">
                    <h3>No selection</h3>
                    <p>Select a commit to view file changes, or <a href="#" onclick="showWorkingDirectoryChanges()">view working directory changes</a></p>
                </div>
            `;
        }
    }

    showWorkingDirectoryChanges() {
        console.log('Showing working directory changes');
        this.vscode.postMessage({
            command: 'showWorkingDirectoryChanges'
        });
    }

    updateFileChangesPanel(commit, files) {
        const filesContent = document.getElementById('filesContent');
        if (!filesContent) return;

        // Clear previous file compare data
        this.fileCompareData = {};

        if (!files || files.length === 0) {
            filesContent.innerHTML = `
                <div class="empty-state">
                    <h3>No file changes</h3>
                    <p>This commit has no file changes</p>
                </div>
            `;
            return;
        }

        // Generate file changes tree with current commit selection context
        const fileTreeHtml = this.generateFileTreeHtml(files);
        
        // Generate commit details
        const commitDetailsHtml = this.generateCommitDetailsHtml(commit);

        // Generate compare against header
        const compareHeaderHtml = this.generateCompareHeaderHtml();

        filesContent.innerHTML = `
            <div class="file-changes-container">
                ${compareHeaderHtml}
                <div class="file-changes-tree">
                    ${fileTreeHtml}
                </div>
                <div class="commit-details">
                    ${commitDetailsHtml}
                </div>
            </div>
        `;
    }

    generateFileTreeHtml(files) {
        // Create a proper tree structure
        const tree = {};
        
        files.forEach((file) => {
            const parts = file.file.split('/');
            let current = tree;
            
            // Navigate/create directory structure
            for (let i = 0; i < parts.length - 1; i++) {
                const part = parts[i];
                if (!current[part]) {
                    current[part] = { type: 'directory', children: {} };
                }
                current = current[part].children;
            }
            
            // Add the file
            const fileName = parts[parts.length - 1];
            current[fileName] = { type: 'file', ...file };
        });

        return this.generateFileTreeItemsHtml(tree, 0);
    }

    generateFileTreeItemsHtml(tree, depth) {
        let html = '';
        const entries = Object.entries(tree).filter(([key, value]) => value !== undefined);
        
        // Sort entries: directories first, then files, both alphabetically
        const sortedEntries = entries.sort(([a, b], [aItem, bItem]) => {
            const aIsDir = aItem.type === 'directory';
            const bIsDir = bItem.type === 'directory';
            
            if (aIsDir && !bIsDir) return -1;
            if (!aIsDir && bIsDir) return 1;
            return a.localeCompare(b);
        });

        sortedEntries.forEach(([name, item]) => {
            if (item.type === 'directory') {
                const hasChildren = Object.keys(item.children).length > 0;
                const toggleClass = hasChildren ? 'tree-toggle' : 'tree-toggle-empty';
                const toggleIcon = hasChildren ? '▼' : '';
                
                html += `
                    <div class="file-tree-item directory" 
                         style="margin-left: ${depth * 4}px"
                         oncontextmenu="event.preventDefault(); showDirectoryContextMenu(event, '${name}')">
                        <div class="file-tree-header" onclick="toggleFileTreeItem(this)">
                            <span class="${toggleClass}">${toggleIcon}</span>
                            <span class="file-icon">📁</span>
                            <span class="file-name">${name}</span>
                        </div>
                        <div class="file-tree-children">
                            ${this.generateFileTreeItemsHtml(item.children, depth + 1)}
                        </div>
                    </div>
                `;
            } else {
                // This is a file
                const statusIcon = this.getFileStatusIcon(item.status);
                const changeStats = this.getFileChangeStats(item);
                
                // Generate file click handler based on compare option and selected commits
                const selectedCommits = Array.from(this.selectedCommits);
                const compareData = this.getCompareData(selectedCommits);
                
                // Create a unique ID for this file item to store the compare data
                const fileId = `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                html += `
                    <div class="file-tree-item file" 
                         style="margin-left: ${depth * 8}px" 
                         data-file-id="${fileId}"
                         oncontextmenu="event.preventDefault(); showFileContextMenu(event, '${item.file}', '${fileId}')">
                        <div class="file-content" onclick="showFileDiffWithCompare('${item.file}', '${fileId}')">
                            <span class="file-icon">${statusIcon}</span>
                            <span class="file-name">${name}</span>
                            <span class="file-stats">${changeStats}</span>
                            <div class="file-actions">
                                <span class="action-icon" title="Open editable diff" onclick="event.stopPropagation(); showEditableDiff('${item.file}', '${fileId}')">✏️</span>
                                <span class="action-icon" title="Open working file" onclick="event.stopPropagation(); openWorkingFile('${item.file}')">📄</span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Store the compare data for this file
                this.fileCompareData = this.fileCompareData || {};
                this.fileCompareData[fileId] = compareData;
            }
        });

        return html;
    }

    getFileStatusIcon(status) {
        switch (status) {
            case 'A': return '🆕';
            case 'D': return '🗑️';
            case 'M': return '📝';
            case 'R': return '🔄';
            case 'C': return '📋';
            case 'U': return '❓';
            default: return '📄';
        }
    }

    getFileChangeStats(file) {
        if (file.additions > 0 && file.deletions > 0) {
            return `+${file.additions} -${file.deletions}`;
        } else if (file.additions > 0) {
            return `+${file.additions}`;
        } else if (file.deletions > 0) {
            return `-${file.deletions}`;
        }
        return '';
    }

    generateCompareHeaderHtml() {
        const selectedCommits = Array.from(this.selectedCommits);
        const isMultipleCommits = selectedCommits.length > 1;
        
        return `
            <div class="compare-header">
                <div class="compare-header-content">
                    <span class="compare-label">Compare Against:</span>
                    <select class="compare-select" onchange="changeCompareOption(this.value)">
                        <option value="previous" ${this.compareAgainst === 'previous' ? 'selected' : ''}>Previous Commit</option>
                        <option value="branch" ${this.compareAgainst === 'branch' ? 'selected' : ''}>Branch</option>
                        <option value="working" ${this.compareAgainst === 'working' ? 'selected' : ''}>Working Directory</option>
                    </select>
                    ${this.compareAgainst === 'branch' ? `
                        <select class="branch-select" onchange="changeCompareBranch(this.value)">
                            <option value="">Select branch...</option>
                            ${this.branches.map(branch => `
                                <option value="${branch.name}" ${branch.name === this.selectedCompareBranch ? 'selected' : ''}>
                                    ${branch.isRemote ? branch.name.split('/').slice(1).join('/') : branch.name}
                                </option>
                            `).join('')}
                        </select>
                    ` : ''}
                </div>
                <div class="compare-info">
                    ${isMultipleCommits ? 
                        `Showing changes for ${selectedCommits.length} commits` : 
                        `Showing changes for selected commit`
                    }
                </div>
            </div>
        `;
    }

    generateCommitDetailsHtml(commit) {
        if (!commit) return '';

        const date = new Date(commit.date);
        const formattedDate = date.toLocaleDateString();
        const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        return `
            <div class="commit-details-header">
                <h3>Commit Details</h3>
            </div>
            <div class="commit-details-content">
                <div class="commit-detail-item">
                    <span class="commit-detail-label">Hash:</span>
                    <span class="commit-detail-value">${commit.shortHash}</span>
                </div>
                <div class="commit-detail-item">
                    <span class="commit-detail-label">Author:</span>
                    <span class="commit-detail-value">${commit.author}</span>
                </div>
                <div class="commit-detail-item">
                    <span class="commit-detail-label">Date:</span>
                    <span class="commit-detail-value">${formattedDate} ${formattedTime}</span>
                </div>
                <div class="commit-detail-item">
                    <span class="commit-detail-label">Message:</span>
                    <span class="commit-detail-value">${commit.message}</span>
                </div>
                ${commit.refs && commit.refs.length > 0 ? `
                    <div class="commit-detail-item">
                        <span class="commit-detail-label">Refs:</span>
                        <span class="commit-detail-value">${commit.refs.join(', ')}</span>
                    </div>
                ` : ''}
            </div>
        `;
    }

    refreshData() {
        console.log('refreshData called');
        this.vscode.postMessage({ command: 'refresh' });
    }

    showSquashDialog() {
        const commitHashes = Array.from(this.selectedCommits);
        const selectedCommitsList = this.commits.filter(c => this.selectedCommits.has(c.hash));
        
        const defaultMessage = selectedCommitsList.map(c => c.message).join('\n');
        
        const message = prompt('Enter commit message for squashed commit:', defaultMessage);
        if (message) {
            this.vscode.postMessage({
                command: 'squashCommits',
                commitHashes: commitHashes,
                message: message
            });
        }
    }

    getCurrentCommitHash() {
        // Return the first selected commit hash, or null if none selected
        if (this.selectedCommits.size > 0) {
            return Array.from(this.selectedCommits)[0];
        }
        return null;
    }

    getCompareData(selectedCommits) {
        const data = {
            compareAgainst: this.compareAgainst,
            selectedCommits: selectedCommits
        };

        switch (this.compareAgainst) {
            case 'previous':
                // Compare against previous commit(s)
                break;
            case 'branch':
                data.compareBranch = this.selectedCompareBranch;
                break;
            case 'working':
                // Compare against working directory
                break;
        }

        return data;
    }

    changeCompareOption(option) {
        this.compareAgainst = option;
        this.selectedCompareBranch = null;
        
        // Save the compare option to localStorage
        localStorage.setItem('gitstorm-compare-against', option);
        
        // Refresh the file changes panel to update the compare header
        const selectedCommits = Array.from(this.selectedCommits);
        if (selectedCommits.length === 1) {
            this.showCommitFileChanges(selectedCommits[0]);
        } else if (selectedCommits.length > 1) {
            this.showMultiCommitFileChanges(selectedCommits);
        }
    }

    changeCompareBranch(branchName) {
        this.selectedCompareBranch = branchName;
        
        // Save the selected branch to localStorage
        localStorage.setItem('gitstorm-compare-branch', branchName);
        
        // Refresh the file changes panel
        const selectedCommits = Array.from(this.selectedCommits);
        if (selectedCommits.length === 1) {
            this.showCommitFileChanges(selectedCommits[0]);
        } else if (selectedCommits.length > 1) {
            this.showMultiCommitFileChanges(selectedCommits);
        }
    }

    changeCommitsCompareOption(branchName) {
        this.commitsCompareAgainst = branchName;
        
        // Save the selection to localStorage
        localStorage.setItem('gitstorm-commits-compare-against', branchName);
        
        // Request commits with compare from backend
        if (this.currentBranch) {
            this.vscode.postMessage({
                command: 'getCommitsWithCompare',
                branch: this.currentBranch,
                compareBranch: branchName
            });
        } else {
            // If no branch selected, refresh current commits
            this.filterCommits();
        }
    }

    updateCommitsWithCompare(commits, branch, compareBranch, error) {
        if (error) {
            console.error('Error loading commits with compare:', error);
            const commitsContent = document.getElementById('commitsContent');
            if (commitsContent) {
                commitsContent.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${error}</p></div>`;
            }
            return;
        }

        // Update the commits array
        this.commits = commits || [];
        
        // Update the compare dropdown selection to match what was used
        const compareSelect = document.querySelector('.commits-compare .compare-select');
        if (compareSelect) {
            compareSelect.value = compareBranch || 'none';
        }
        
        // Update branch highlighting to show the selected branch
        this.updateBranchHighlighting(branch);
        
        // Update the commits display
        const commitsContent = document.getElementById('commitsContent');
        if (commitsContent) {
            const newHtml = this.generateCommitsHtml(this.commits, this.commitsSearchTerm, this.selectedUser);
            commitsContent.innerHTML = newHtml;
            // Restore commit selection after content update
            setTimeout(() => this.updateCommitSelection(), 10);
        }
    }

    updateBranchHighlighting(selectedBranch) {
        // Update branch highlighting in the branches panel
        const branchItems = document.querySelectorAll('.branch-item');
        branchItems.forEach(item => {
            const branchName = item.getAttribute('onclick');
            if (branchName) {
                // Extract branch name from onclick="selectBranch('branchName')"
                const match = branchName.match(/selectBranch\('([^']+)'\)/);
                if (match) {
                    const itemBranchName = match[1];
                    if (itemBranchName === selectedBranch) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                }
            }
        });
    }
}

// Global functions for HTML onclick handlers
let panelController;

function selectBranch(branchName) {
    panelController.selectBranch(branchName);
}

function selectCommit(hash, event) {
    panelController.selectCommit(hash, event);
}

function refreshData() {
    panelController.refreshData();
}

function showSquashDialog() {
    panelController.showSquashDialog();
}

function toggleSection(sectionId) {
    panelController.toggleSection(sectionId);
}

function clearSearch() {
    panelController.clearSearch();
}

function clearCommitsSearch() {
    panelController.clearCommitsSearch();
}

function filterByUser(user) {
    panelController.filterByUser(user);
}

function toggleFileTreeItem(element) {
    const children = element.parentElement.querySelector('.file-tree-children');
    const toggle = element.querySelector('.tree-toggle');
    
    if (children && toggle) {
        const isCollapsed = children.style.display === 'none';
        children.style.display = isCollapsed ? 'block' : 'none';
        toggle.textContent = isCollapsed ? '▼' : '▶';
    }
}

function showFileDiff(filePath, commitHash) {
    console.log('Show file diff for:', filePath, 'commit:', commitHash);
    panelController.vscode.postMessage({
        command: 'showFileDiff',
        filePath: filePath,
        commitHash: commitHash
    });
}

function showMultiCommitFileDiff(filePath, commitHashes) {
    console.log('Show multi-commit file diff for:', filePath, 'commits:', commitHashes);
    panelController.vscode.postMessage({
        command: 'showMultiCommitFileDiff',
        filePath: filePath,
        commitHashes: commitHashes
    });
}

function showFileDiffWithCompare(filePath, fileId) {
    console.log('Show file diff with file ID:', filePath, fileId);
    
    // Update selected file highlighting
    panelController.updateFileSelection(fileId);
    
    // Get the compare data from the stored data
    const compareData = panelController.fileCompareData && panelController.fileCompareData[fileId];
    if (!compareData) {
        console.error('No compare data found for file ID:', fileId);
        return;
    }
    
    console.log('Compare data:', compareData);
    panelController.vscode.postMessage({
        command: 'showFileDiffWithCompare',
        filePath: filePath,
        compareData: compareData
    });
}

function changeCompareOption(option) {
    panelController.changeCompareOption(option);
}

function changeCompareBranch(branchName) {
    panelController.changeCompareBranch(branchName);
}

function changeCommitsCompareOption(branchName) {
    panelController.changeCommitsCompareOption(branchName);
}

function showWorkingDirectoryChanges() {
    panelController.showWorkingDirectoryChanges();
}

function showEditableDiff(filePath, fileId) {
    console.log('Show editable diff for:', filePath, fileId);
    
    // Get the compare data from the stored data
    const compareData = panelController.fileCompareData && panelController.fileCompareData[fileId];
    if (!compareData) {
        console.error('No compare data found for file ID:', fileId);
        return;
    }
    
    console.log('Editable diff compare data:', compareData);
    panelController.vscode.postMessage({
        command: 'showEditableDiff',
        filePath: filePath,
        compareData: compareData
    });
}

function openWorkingFile(filePath) {
    console.log('Open working file:', filePath);
    panelController.vscode.postMessage({
        command: 'openWorkingFile',
        filePath: filePath
    });
}

// Context Menu Functions
function showBranchContextMenu(event, branchName) {
    event.preventDefault();
    const rect = event.target.getBoundingClientRect();
    
    // Select the branch first
    selectBranch(branchName);
    
    // Show custom context menu
    panelController.showContextMenu(event.clientX, event.clientY, 'branch', { branchName });
}

function showCommitContextMenu(event, commitHash) {
    event.preventDefault();
    const rect = event.target.getBoundingClientRect();
    
    // Select the commit first
    selectCommit(commitHash, event);
    
    // Show custom context menu
    panelController.showContextMenu(event.clientX, event.clientY, 'commit', { commitHash });
}

function showFileContextMenu(event, filePath, fileId) {
    event.preventDefault();
    const rect = event.target.getBoundingClientRect();
    
    // Select the file first
    panelController.updateFileSelection(fileId);
    
    // Show custom context menu
    panelController.showContextMenu(event.clientX, event.clientY, 'file', { filePath, fileId });
}

function showDirectoryContextMenu(event, directoryName) {
    event.preventDefault();
    const rect = event.target.getBoundingClientRect();
    
    // Show custom context menu for directory
    panelController.showContextMenu(event.clientX, event.clientY, 'directory', { directoryName });
}

function showPanelContextMenu(event, panelType) {
    event.preventDefault();
    const rect = event.target.getBoundingClientRect();
    
    // Show custom context menu for panel
    panelController.showContextMenu(event.clientX, event.clientY, 'panel', { panelType });
}

function selectUncommittedChanges() {
    panelController.selectUncommittedChanges();
}

function showUncommittedChangesContextMenu(event) {
    event.preventDefault();
    const rect = event.target.getBoundingClientRect();
    
    // Show custom context menu for uncommitted changes
    panelController.showContextMenu(event.clientX, event.clientY, 'uncommitted', {});
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    panelController = new PanelController();
});
